%-------------------------------------------------------------------------------
% 
\chapter{Glossary}
%-------------------------------------------------------------------------------
\emph{Antecedent (predicate logic)} is a first half of the hypothetical 
proposition. It is a $p$ part of the implies statement (see symbol $\implies$ in
Chapter Symbols for explanation. In an implication $p \implies q$, $p$ is an
antecedent.\\

\emph{Arity (predicate logic)} is a property of predicate that defines the 
number of parameters or operands that predicate can operate with. For example,
if a predicate $P$ has \emph{arity} of 2, valid statements using this predicate
can only be the ones with exactly 2 operands ($P(x,y), P(a,b),...$). Statement
$P(x)$ is in this case not a valid statement, since it uses the predicate with
only one parameter.\\

\emph{AST (Abstract Syntax Tree)} is an abstract representation of Wikipedia 
page as parsed from DBPedia parser. Something like DOM tree for Wikipedia 
instead for pure HTML\\

\emph{Atomic Formula} (predicate logic). If the predicate $P$ has arity $n$,
then $P$ followed by $n$ constants and variables is an atomic formula. Examples:
$P(a), P(x), P(x,y) D(a,x)$.\\

\emph{Backward Chaining} or backward reasoning is the opposite of the 
\emph{forward chaining}. It also uses \emph{modus ponens}, but instead of 
starting from the data, it starts with a list of goals and scans all the 
consequents of the implication rules in the KB, check if they holds and then
tries to find whether antecedents supporting these consequents hold as well.
The inference engine will continue to do the inference iterations until it will
find an assertion or rule which has a consequent that matches a desired goal.\\

\emph{Consequent (predicate logic)} is a second half of the hypothetical 
proposition. It is a $q$ part of the implies statement (see symbol $\implies$ in
Chapter Symbols for explanation. In an implication $p \implies q$, $q$ is a
consequent or apodosis.\\

\emph{Constant} (predicate logic) is besides \emph{variables}, 
\emph{predicates}, and \emph{quantifiers} one of the atomic parts of the 
\emph{predicate logic} sentences. For example, in a sentence $P(a,x)$, $a$ 
serves as a constant. Constants are usually marked with the letters from the
beginning of the alphabet. In this thesis, also predicate is a constant and
all constants are written either with letters or their $Names$.\\

\emph{Existential Quantifier ($\exists$)}. For explanation see the symbol
$\exists$ in the chapter Symbols.\\

\emph {First order logic} can also be called \emph{Predicate logic}. See this
term for more refined definition\\

\emph{Forward Chaining} or forward reasoning is a repeated application of
\emph{modus ponens} inference rule. It starts with the available knowledge in 
the KB, then it applies the existing rules to infer new knowledge. Then in
another iteration it can use newly inferred knowledge to produce even more 
knowledge, and this continues until the goal is reached, or there is no new
knowledge during the last iteration.\\

\emph{Knowledge Acquisition Bottleneck} is the slow process involved with
the programmatic acquisition of the knowledge to be able to use it in software.
It is considered a "bottleneck" because usually other parts of the software
modules involved in knowledge based application (GUI, inference engine), are
relatively fast to implement.\\

\emph{Material Equivalence ($\iff$)}. For explanation see the symbol $\iff$ in the
chapter Symbols.\\

\emph{Material implication ($\implies$)}. For explanation, see $\implies$ in the
Chapter Symbols.\\

\emph{Modus Ponens} is a logical inference rule stating that if an antecedent
of the logical implication holds, then also the consequent holds and can be
inferred. For example, a statement "if person is a 
programmer, then he knows how to use a computer". If we get the information
that this person is a programmer, we can infer that this person knows how to
use a computer. \\

\emph{Modus Tollens} is a logical inference rule stating that if an antecedent
of the logical implication holds but the consequent does not, then the negation
of the antecedent can be inferred. For example, a statement "if person is a 
programmer, then he knows how to use a computer". If we get the information
that this person cannot use a computer, and consider the previous statement, we
can infer that this person is not a programmer. \\

\emph{OIE (Open Information Extraction} is a paradigm introduced by Oren Etzioni
in his TextRunner system. The main idea of this paradigm is that the knowledge 
acquisition system is not predetermined to extract some specific facts, 
patterns, etc, but is open-ended, extracting large set of relational tuples 
without any human input.\\

\emph{PMI (Point-wise Mutual Information} is a measure which captures 
co-occurrence relationship between terms in a big corpus.\\

\emph{predicate} is a a term used in predicate logic, representing a verb
template that describes properties of objects, or relationships between multiple
objects.\\

\emph{Predicate logic}, called also \emph{First order logic} is a formal system
that uses quantification over variables. This makes this logic more expressive
than the \emph{Propositional logic}. In some limited sense, 
\emph{Predicate logic} could be defined as \emph{Propositional logic} with 
quantifiers.\\

\emph{proposition}. This term is often synonym for a logical \emph{statement},
but can also mean more abstract meaning that two different statements with the
same meaning represent. In \emph{Propositional logic}, a proposition is the
smallest syntactic unit. On the other hand, in \emph{Predicate logic}, 
statements/sentences are broken into \emph{constants, variables, predicates}
and \emph{quantifiers}.\\

\emph{Propositional function}, is an atomic function in from the 
\emph{Predicate logic} which is open ended (missing quantifiers) and thus
cannot count as proposition. For example, $P(x)$ is a propositional function,
while $\forall x P(x)$ is a proposition.\\

\emph{Propositional logic}, also known as \emph{sentential} or 
\emph{statement logic}, is the branch of logic that operates with entire
propositions/statements/sentences to form more complicated 
propositions/statements/sentences, and also logical relationships and properties
derived from combining  or altering this statements.\\

\emph{Quantifier} (logical). Quantifiers in \emph{Predicate logic} convert
propositional functions (open ended) into proper propositions which can be true
or false. For example, $P(x)$ is a propositional function, which can get
converted into proper proposition using one of the quantifiers: 
$\forall x P(x)$. For more info look for the terms \emph{Universal Quantifier}
and \emph{Existential Quantifier}.\\

\emph{Sentential logic}. See the term \emph{Propositional logic}.\\

\emph{SKSI (Semantic Knowledge Source Integration)} is a \emph{Cyc} sub-system
for external knowledge integration.\\

\emph{Statement logic}. Synonym for \emph{Propositional logic}. For description
see the glossary for this term.\\

\emph{Upper Ontology} (also top-level, foundation or core ontology) is the part
of ontology (or knowledge base), which defines the core objects that serve as a
main knowledge building blocks to construct the full knowledge base.\\

\emph{Universal Quantifier ($\forall$)}. For explanation check the symbol 
$\forall$ in the chapter Symbols. \\
